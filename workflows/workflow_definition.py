from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage
from core.state import ExtendedMessagesState
from core.graph_logic import start_node, summarization_node
from core.checkpoint import get_checkpointer


def build_workflow() -> StateGraph:
    """
    Builds the workflow graph with defined nodes and transitions.
    """
    workflow = StateGraph(ExtendedMessagesState)

    # Register nodes
    workflow.add_node("start_node", start_node)
    workflow.add_node("summarization_node", summarization_node)

    # Define edges between nodes
    workflow.add_edge(START, "start_node")
    workflow.add_edge("start_node", "summarization_node")
    workflow.add_edge("summarization_node", END)

    return workflow


def run_workflow(message: str, thread_id: str) -> ExtendedMessagesState:
    """
    Executes the workflow using a given initial message.
    Returns the final state generated by the workflow.
    """
    workflow = build_workflow()
    checkpointer = get_checkpointer()
    graph = workflow.compile(checkpointer=checkpointer)

    config = {"configurable": {"thread_id": thread_id}}

    # Prepare initial state
    initial_state = ExtendedMessagesState(
        messages=[HumanMessage(content=message)],
        summary=""
    )

    # Run the graph
    return graph.invoke(initial_state, config=config)


if __name__ == "__main__":
    final_state = run_workflow(message="Hello World!", thread_id="1")
    print("Summary:", final_state["summary"])
